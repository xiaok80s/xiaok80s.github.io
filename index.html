<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Audio Player</title>

    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="Audio Player" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="theme-color" content="#4a90e2" />

    <!-- PWA Icons -->
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiByeD0iMjAiIGZpbGw9IiM0YTkwZTIiLz4KPHN2ZyB4PSI0NSIgeT0iNDUiIHdpZHRoPSI5MCIgaGVpZ2h0PSI5MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik04IDV2MTRsNy03eiIvPgo8L3N2Zz4KPC9zdmc+" />
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iNCIgZmlsbD0iIzRhOTBlMiIvPgo8c3ZnIHg9IjgiIHk9IjgiIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik04IDV2MTRsNy03eiIvPgo8L3N2Zz4KPC9zdmc+" />

    <!-- PWA Manifest -->
    <link
      rel="manifest"
      href="data:application/json;base64,ewogICJuYW1lIjogIkF1ZGlvIFBsYXllciIsCiAgInNob3J0X25hbWUiOiAiQXVkaW8gUGxheWVyIiwKICAiZGVzY3JpcHRpb24iOiAiQSBtaW5pbWFsIGF1ZGlvIHBsYXllciB3aXRoIHNlbnRlbmNlIGRldGVjdGlvbiBhbmQgc3VidGl0bGUgc3VwcG9ydCIsCiAgInN0YXJ0X3VybCI6ICIuLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiI2Y1ZjdmYSIsCiAgInRoZW1lX2NvbG9yIjogIiM0YTkwZTIiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOVEV5SWlCb1pXbG5hSFE5SWpVeE1pSWlJSFpwWlhkQ2IzZzlJakFnTUNBMU1USWdOVEV5SWlCbWFXeHNQU0p1YjI1bElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaVBnbzhjbVZqZENCM2FXUjBhRDBpTlRFeUlpQm9aV2xuYUhROUlqVXhNaUlpSUhKNFBTSXlNQ0lpSUdacGJHdzlJaU0wWVRrd1pUSWlMejRLUEhOMlp5QjRQU0k0TWlJZ2VUMGlPREVpSUhkcFpIUm9QU0l6TkRnaUlHaGxhV2RvZEQwaU16UTRJaUIyYVdWM1FtOTRQU0l3SURBZ01qUWdNalFpSUdacGJHdzlJbmRvYVhSbElqNEtQSEJoZEdnZ1pEMGlUVGcySURWMk1UUnNOeTAzZWlJdlBnbzhMM04yWno0S1BDOXpkbWMrIiwKICAgICAgInNpemVzIjogIjUxMng1MTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfSwKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVGd3SWlCb1pXbG5hSFE5SWpFNE1DSWlJSFpwWlhkQ2IzZzlJakFnTUNBeE9EQWdNVGd3SWlCbWFXeHNQU0p1YjI1bElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaVBnbzhjbVZqZENCM2FXUjBhRDBpTVRnd0lpQm9aV2xuYUhROUlqRTRNQ0lpSUhKNFBTSXlNQ0lpSUdacGJHdzlJaU0wWVRrd1pUSWlMejRLUEhOMlp5QjRQU0kwTlNJZ2VUMGlORFVpSUhkcFpIUm9QU0k1TUNJZ2FHVnBaMmgwUFNJNU1DSWlJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lpSUdacGJHdzlJbmRvYVhSbElqNEtQSEJoZEdnZ1pEMGlUVGdnTldZeE5HeDBOeTAzZWlJdlBnbzhMM04yWno0S1BDOXpkbWMrIiwKICAgICAgInNpemVzIjogIjE5MngxOTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfQogIF0sCiAgIm9yaWVudGF0aW9uIjogInBvcnRyYWl0Igp9" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Arial', sans-serif;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
        margin: 0;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      .container {
        background: white;
        border-radius: 20px;
        padding: 40px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        text-align: center;
        max-width: 500px;
        width: 100%;
        position: relative;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-drag: none;
        -khtml-user-drag: none;
        -moz-user-drag: none;
        -o-user-drag: none;
        pointer-events: auto;
        touch-action: manipulation;
      }

      h1 {
        color: #333;
        margin-bottom: 30px;
        font-size: 2rem;
        font-weight: 300;
      }

      .file-info {
        margin-bottom: 30px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 10px;
        color: #666;
        font-size: 0.9rem;
        flex: 1;
        text-align: left;
        margin-right: 15px;
        margin-bottom: 0;
      }

      .file-row {
        display: flex;
        align-items: center;
        margin-bottom: 30px;
        gap: 15px;
      }

      .file-row .open-file {
        margin: 0;
        flex-shrink: 0;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 30px;
        flex-wrap: wrap;
      }

      button {
        background: #4a90e2;
        color: white;
        border: none;
        border-radius: 50px;
        padding: 12px 20px;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
      }

      button:hover {
        background: #357abd;
        box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
      }

      /* Keep hover transform effect only on devices that support hover (desktop) */
      @media (hover: hover) and (pointer: fine) {
        button:hover {
          transform: translateY(-2px);
        }
      }

      /* iOS Safari touch handling */
      button {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        touch-action: manipulation;
      }

      button:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .open-file {
        background: #28a745;
        box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
      }

      .open-file:hover {
        background: #218838;
        box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
      }

      .open-file[style*='background: #17a2b8']:hover {
        background: #138496 !important;
        box-shadow: 0 6px 20px rgba(23, 162, 184, 0.4) !important;
      }

      .nav-button {
        background: #6c757d;
        box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
      }

      .nav-button:hover {
        background: #5a6268;
        box-shadow: 0 6px 20px rgba(108, 117, 125, 0.4);
      }

      .lyrics-toggle-container {
        display: none;
        justify-content: center;
        align-items: center;
      }

      .lyrics-toggle-container.visible {
        display: flex;
      }

      .lyrics-toggle {
        background: #17a2b8;
        box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3);
        font-size: 0.9rem;
        padding: 8px 16px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .lyrics-toggle:hover {
        background: #138496;
        box-shadow: 0 6px 20px rgba(23, 162, 184, 0.4);
      }

      .lyrics-toggle.active {
        background: #28a745;
        box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
      }

      .lyrics-toggle.active:hover {
        background: #218838;
        box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
      }

      .toggle-icon {
        font-size: 1rem;
        transition: transform 0.2s ease;
      }

      .lyrics-toggle.active .toggle-icon {
        transform: rotate(180deg);
      }

      /* Toggle buttons container */
      .toggle-buttons-container {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 20px;
      }

      /* Desktop-only hover transform effects */
      @media (hover: hover) and (pointer: fine) {
        button:active {
          transform: translateY(0);
        }
      }

      .progress-container {
        margin-bottom: 20px;
      }

      .progress-bar {
        width: 100%;
        height: 8px;
        background: #e9ecef;
        border-radius: 10px;
        overflow: hidden;
        cursor: pointer;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        position: relative;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4a90e2, #357abd);
        width: 0%;
        transition: width 0.1s ease;
        border-radius: 10px;
      }

      .segment-marker {
        position: absolute;
        top: 0;
        width: 2px;
        height: 100%;
        background: #28a745;
        opacity: 0.7;
        pointer-events: none;
      }

      .current-segment-marker {
        background: #fd7e14;
        width: 3px;
        opacity: 1;
      }
      .time-display {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 10px;
        font-size: 0.9rem;
        color: #666;
      }

      .speed-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .speed-btn {
        background: #6c757d;
        color: white;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        font-size: 0.8rem;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        box-shadow: 0 2px 8px rgba(108, 117, 125, 0.3);
      }

      .speed-btn:hover {
        background: #5a6268;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(108, 117, 125, 0.4);
      }

      .speed-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .speed-display {
        font-size: 0.8rem;
        color: #666;
        min-width: 35px;
        text-align: center;
      }

      .icon {
        font-size: 1.2rem;
      }

      input[type='file'] {
        display: none;
      }

      .status {
        margin-top: 20px;
        padding: 10px;
        border-radius: 8px;
        font-size: 0.9rem;
      }

      .status.playing {
        background: #d4edda;
        color: #155724;
      }

      .status.paused {
        background: #fff3cd;
        color: #856404;
      }

      .status.stopped {
        background: #f8d7da;
        color: #721c24;
      }

      .current-text {
        margin-top: 25px;
        padding: 20px;
        background: linear-gradient(135deg, #fff9e6 0%, #f0f8ff 100%);
        border-radius: 15px;
        border: 2px solid #e3f2fd;
        min-height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .text-content {
        font-size: 1.1rem;
        line-height: 1.6;
        color: #333;
        text-align: center;
        font-weight: 500;
        max-width: 100%;
        word-wrap: break-word;
      }

      .text-content.highlighted {
        animation: pulse 0.3s ease;
      }

      /* Enhanced LRC word-level highlighting styles */
      .text-content.enhanced-lrc {
        font-size: 1.1rem;
        line-height: 1.6;
      }

      .word-normal {
        color: #666;
      }

      .word-highlight {
        color: #4a90e2;
        font-weight: 600;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.02);
        }
        100% {
          transform: scale(1);
        }
      }

      @media (max-width: 600px) {
        .container {
          padding: 20px;
        }

        h1 {
          font-size: 1.5rem;
          margin-bottom: 20px;
        }

        .file-row {
          flex-direction: column;
          gap: 10px;
          margin-bottom: 20px;
        }

        .file-info {
          margin-bottom: 10px;
          padding: 10px;
          font-size: 0.8rem;
          margin-right: 0;
          text-align: center;
          width: 100%;
        }

        .file-row .open-file {
          width: 100%;
        }

        .controls {
          flex-direction: row;
          flex-wrap: nowrap;
          gap: 8px;
          margin-bottom: 20px;
        }

        button {
          min-width: auto;
          padding: 10px 12px;
          font-size: 0.8rem;
          flex: 1;
          justify-content: center;
        }

        .nav-button {
          flex: 1;
          min-width: 0;
        }

        .lyrics-toggle-container {
          margin-bottom: 15px;
        }

        .toggle-buttons-container {
          margin-bottom: 15px;
          gap: 8px;
        }

        .lyrics-toggle {
          padding: 6px 12px;
          font-size: 0.8rem;
        }

        .progress-container {
          margin-bottom: 15px;
        }

        .current-text {
          margin-top: 15px;
          padding: 15px;
          min-height: 60px;
        }

        .text-content {
          font-size: 1rem;
          line-height: 1.4;
        }

        /* Mobile word highlighting adjustments */
        .word-highlight {
          font-size: 0.95rem;
        }

        .word-normal {
          font-size: 0.95rem;
        }
      }

      @media (max-width: 400px) {
        .container {
          padding: 15px;
        }

        h1 {
          font-size: 1.3rem;
          margin-bottom: 15px;
        }

        .file-row {
          gap: 8px;
          margin-bottom: 15px;
        }

        .file-info {
          margin-bottom: 8px;
          padding: 8px;
          font-size: 0.75rem;
        }

        .controls {
          gap: 6px;
          margin-bottom: 15px;
        }

        button {
          padding: 8px 10px;
          font-size: 0.75rem;
        }

        .nav-button {
          flex: 1;
          min-width: 0;
        }

        .lyrics-toggle-container {
          margin-bottom: 12px;
        }

        .toggle-buttons-container {
          margin-bottom: 12px;
          gap: 6px;
        }

        .lyrics-toggle {
          padding: 5px 10px;
          font-size: 0.75rem;
        }

        .file-row .open-file {
          padding: 10px 15px;
          font-size: 0.85rem;
        }

        .icon {
          font-size: 1rem;
        }

        .progress-bar {
          height: 6px;
        }

        .time-display {
          font-size: 0.8rem;
          margin-top: 8px;
        }

        .current-text {
          margin-top: 12px;
          padding: 12px;
          min-height: 50px;
        }

        .text-content {
          font-size: 0.9rem;
          line-height: 1.3;
        }

        /* Small mobile word highlighting adjustments */
        .word-highlight {
          font-size: 0.85rem;
        }

        .word-normal {
          font-size: 0.85rem;
        }
      }

      /* Help Overlay Styles */
      #helpOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      #helpOverlay.show {
        opacity: 1;
      }

      .help-content {
        background: white;
        padding: 30px;
        border-radius: 15px;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        text-align: center;
        transform: scale(0.9);
        transition: transform 0.3s ease;
      }

      #helpOverlay.show .help-content {
        transform: scale(1);
      }

      .help-content h3 {
        margin-bottom: 20px;
        color: #333;
        font-size: 1.4rem;
      }

      .shortcut-list {
        text-align: left;
        margin-bottom: 20px;
      }

      .shortcut-list div {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        border-bottom: 1px solid #eee;
      }

      .shortcut-list div:last-child {
        border-bottom: none;
      }

      kbd {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 4px 8px;
        font-family: monospace;
        font-size: 0.9rem;
        color: #495057;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .help-note {
        font-size: 0.9rem;
        color: #666;
        margin: 0;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸŽµ Audio Player</h1>

      <div class="file-row">
        <div class="file-info" id="fileInfo">No audio file selected</div>
        <button
          class="open-file"
          onclick="handleFileButtonClick(event)"
          style="background: #17a2b8; box-shadow: 0 4px 15px rgba(23, 162, 184, 0.3)">
          <span class="icon">ðŸŽµ</span>
          Load Files
        </button>
      </div>

      <div class="controls">
        <button class="nav-button" onclick="playNextSentence()" disabled>Next</button>

        <button class="nav-button" onclick="playPreviousSentence()" disabled>Prev</button>

        <button id="playPauseBtn" onclick="togglePlayPause()" disabled>Play</button>
      </div>

      <!-- Toggle Buttons Container -->
      <div class="toggle-buttons-container">
        <!-- Auto Stop Toggle -->
        <div class="auto-stop-toggle-container">
          <button
            class="lyrics-toggle active"
            id="autoStopToggleBtn"
            onclick="toggleAutoStop()">
            <span id="autoStopToggleText">Sentence On</span>
          </button>
        </div>
        <!-- Lyrics Toggle (only visible when LRC loaded) -->
        <div class="lyrics-toggle-container" id="lyricsToggleContainer">
          <button class="lyrics-toggle" id="lyricsToggleBtn" onclick="toggleLyrics()">
            <span id="lyricsToggleText">Show Lyrics</span>
          </button>
        </div>
      </div>

      <div class="progress-container">
        <div class="progress-bar" onclick="seekAudio(event)">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="time-display">
          <span id="currentTime">0:00</span>
          <div class="speed-controls">
            <button
              class="speed-btn"
              id="speedDownBtn"
              onclick="decreaseSpeed()"
              disabled
              title="Decrease Speed">
              âˆ’
            </button>
            <span class="speed-display" id="speedDisplay">1.0x</span>
            <button
              class="speed-btn"
              id="speedResetBtn"
              onclick="resetSpeed()"
              disabled
              title="Reset Speed">
              â—‹
            </button>
            <button
              class="speed-btn"
              id="speedUpBtn"
              onclick="increaseSpeed()"
              disabled
              title="Increase Speed">
              +
            </button>
          </div>
          <span id="duration">0:00</span>
        </div>
      </div>

      <!-- Current Text Display -->
      <div class="current-text" id="currentText" style="display: none">
        <div class="text-content" id="textContent">
          Load audio and LRC files together to see synchronized text here.
        </div>
      </div>

      <!-- Hidden file inputs -->
      <input
        type="file"
        id="bothFilesInput"
        accept="*/*"
        multiple
        onchange="loadBothFiles(event)" />
      <audio id="audioPlayer" onended="onAudioEnded()" loop></audio>
    </div>

    <script>
      // Global variables
      let audioPlayer = document.getElementById('audioPlayer');
      let progressFill = document.getElementById('progressFill');
      let currentTimeSpan = document.getElementById('currentTime');
      let durationSpan = document.getElementById('duration');
      let statusDiv = document.getElementById('status');
      let fileInfoDiv = document.getElementById('fileInfo');

      let isPlaying = false;
      let currentSentenceIndex = 0;
      let sentences = []; // Will store sentence timestamps detected from silence
      let currentFileName = '';
      let audioContext = null;
      let audioBuffer = null;

      // LRC-related variables
      let lrcData = []; // Will store parsed LRC subtitle data
      let currentLrcIndex = -1;
      let lrcLoaded = false;
      let lyricsVisible = false; // Track lyrics display state

      // Sentence-by-sentence playback
      let sentenceBysentenceMode = true; // Default to sentence mode on
      let sentenceEndTimer = null;

      // Initialize event listeners
      audioPlayer.addEventListener('timeupdate', updateProgress);
      audioPlayer.addEventListener('loadedmetadata', onAudioLoaded);
      audioPlayer.addEventListener('play', onPlay);
      audioPlayer.addEventListener('pause', onPause);

      // Initialize lyrics toggle visibility (hidden by default since lrcLoaded = false)
      updateLyricsToggleVisibility();

      // Utility function to detect iOS
      function isIOS() {
        return (
          /iPad|iPhone|iPod/.test(navigator.userAgent) ||
          (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)
        );
      }

      function handleFileButtonClick(event) {
        event.preventDefault();
        event.stopPropagation();

        // Debug logging for iOS Safari
        if (isIOS()) {
          console.log('iOS detected, attempting file selection...');
        }

        openBothFiles();
      }

      function clearCurrentAudioAndLyrics() {
        // Pause the audio
        if (audioPlayer) {
          audioPlayer.pause();
        }

        // Clear the audio source and revoke blob URL if exists
        if (audioPlayer && audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
          URL.revokeObjectURL(audioPlayer.src);
        }
        if (audioPlayer) {
          audioPlayer.src = '';
          audioPlayer.removeAttribute('src');
        }

        // Reset all state variables
        isPlaying = false;
        currentSentenceIndex = 0;
        sentences = [];
        currentFileName = '';
        lrcData = [];
        currentLrcIndex = -1;
        lrcLoaded = false;

        // Reset sentence-by-sentence mode state
        sentenceBysentenceMode = true; // Default to sentence mode on
        if (sentenceEndTimer) {
          clearTimeout(sentenceEndTimer);
          sentenceEndTimer = null;
        }
        lastSentenceIndex = -1;

        // Clear UI elements
        if (fileInfoDiv) {
          fileInfoDiv.textContent = 'No audio file selected';
        }
        if (statusDiv) {
          statusDiv.textContent = 'Ready to load files';
        }
        if (currentTimeSpan) {
          currentTimeSpan.textContent = '0:00';
        }
        if (durationSpan) {
          durationSpan.textContent = '0:00';
        }
        if (progressFill) {
          progressFill.style.width = '0%';
        }

        // Reset speed controls
        const speedDisplay = document.getElementById('speedDisplay');
        if (speedDisplay) {
          speedDisplay.textContent = '1.0x';
        }

        // Clear lyrics display
        const lyricsContainer = document.getElementById('lyricsDisplay');
        if (lyricsContainer) {
          lyricsContainer.innerHTML = '';
          lyricsContainer.style.display = 'none';
        }

        // Reset lyrics toggle
        lyricsVisible = false;
        const lyricsToggleText = document.getElementById('lyricsToggleText');
        if (lyricsToggleText) {
          lyricsToggleText.textContent = 'Show Lyrics';
        }

        // Reset auto-stop toggle to default state (sentence mode on)
        const autoStopToggleBtn = document.getElementById('autoStopToggleBtn');
        const autoStopToggleText = document.getElementById('autoStopToggleText');
        if (autoStopToggleBtn && autoStopToggleText) {
          autoStopToggleBtn.classList.add('active');
          autoStopToggleText.textContent = 'Sentence On';
        }

        // Update lyrics toggle visibility based on lrcLoaded status
        updateLyricsToggleVisibility();

        // Remove sentence markers from progress bar
        const progressContainer = document.querySelector('.progress-container');
        if (progressContainer) {
          const markers = progressContainer.querySelectorAll('.sentence-marker');
          markers.forEach((marker) => marker.remove());
        }

        // Disable control buttons
        const navButtons = document.querySelectorAll('.nav-button');
        navButtons.forEach((button) => {
          button.disabled = true;
        });

        const playPauseBtn = document.getElementById('playPauseBtn');
        if (playPauseBtn) {
          playPauseBtn.disabled = true;
          playPauseBtn.textContent = 'Play';
        }

        // Clean up audio context
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        audioBuffer = null;

        console.log('Cleared all audio and lyrics data');
      }

      function openBothFiles() {
        const fileInput = document.getElementById('bothFilesInput');

        if (isIOS()) {
          // For iOS, we need to ensure the click happens in a user gesture context
          // Reset the input value to ensure change event fires even for same files
          fileInput.value = '';

          // Use a timeout to ensure we're still in the user gesture context
          setTimeout(() => {
            fileInput.click();
          }, 0);
        } else {
          // For other browsers, direct click usually works
          try {
            fileInput.value = ''; // Reset for re-selection of same files
            fileInput.click();
          } catch (error) {
            console.log('Click failed, trying alternative approach:', error);
            // Fallback - create a new input element
            const newInput = document.createElement('input');
            newInput.type = 'file';
            newInput.accept = fileInput.accept;
            newInput.multiple = fileInput.multiple;
            newInput.style.position = 'absolute';
            newInput.style.left = '-9999px';
            newInput.onchange = function (event) {
              loadBothFiles(event);
              document.body.removeChild(newInput);
            };
            document.body.appendChild(newInput);
            newInput.click();
          }
        }
      }

      /**
       * Handles loading both audio and LRC files simultaneously
       * @param {Event} event - File input change event with multiple files
       */
      function loadBothFiles(event) {
        const files = Array.from(event.target.files);

        if (files.length === 0) return;

        // Clear any existing audio and lyrics first when new files are selected
        clearCurrentAudioAndLyrics();

        let audioFile = null;
        let lrcFile = null;

        // Separate audio and LRC files
        files.forEach((file) => {
          if (file.type.startsWith('audio/')) {
            audioFile = file;
          } else if (
            file.name.toLowerCase().endsWith('.lrc') ||
            file.name.toLowerCase().endsWith('.txt')
          ) {
            lrcFile = file;
          }
        });

        // Handle different file combinations gracefully
        if (audioFile && lrcFile) {
          // Both files selected - load them together
          updateStatus('Loading audio and subtitle files...', 'stopped');
          loadAudioFileInternal(audioFile, () => {
            loadLrcFileInternal(lrcFile);
          });
        } else if (audioFile) {
          // Only audio file selected - load it normally
          updateStatus('Loading audio file...', 'stopped');
          loadAudioFileInternal(audioFile);
        } else if (lrcFile) {
          // Only LRC file selected - load it if audio is already loaded
          if (audioPlayer.src) {
            loadLrcFileInternal(lrcFile);
          } else {
            updateStatus('Load an audio file first, then add subtitles', 'stopped');
          }
        }

        // Reset the input
        event.target.value = '';
      }

      /**
       * Attempts to automatically find and load a matching LRC file
       * @param {File} audioFile - The loaded audio file
       */
      function tryAutoLoadLrc(audioFile) {
        // This would require additional file system access which browsers don't allow
        // But we can show a helpful message
        const baseName = audioFile.name.replace(/\.[^/.]+$/, ''); // Remove extension
        updateStatus(
          `Audio loaded. To add subtitles, look for "${baseName}.lrc" and load it using the LRC button below.`,
          'stopped'
        );
      }

      /**
       * Internal function to load audio file with optional callback
       * @param {File} file - Audio file to load
       * @param {Function} callback - Optional callback after loading
       */
      function loadAudioFileInternal(file, callback) {
        if (!file) return;

        // Validate file type
        if (!file.type.startsWith('audio/')) {
          updateStatus('Please select a valid audio file', 'stopped');
          return;
        }

        // Clean up previous blob URL to prevent memory leaks
        if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
          URL.revokeObjectURL(audioPlayer.src);
        }

        currentFileName = file.name;
        const url = URL.createObjectURL(file);
        audioPlayer.src = url;
        audioPlayer.loop = true; // Enable continuous looping
        audioPlayer.playbackRate = 1.0; // Reset playback speed

        fileInfoDiv.innerHTML = `
                  <strong>ðŸ“„ ${currentFileName}</strong>
              `;

        if (!callback) {
          updateStatus('Loading audio file...', 'stopped');
        }

        // Reset player state
        isPlaying = false;
        currentSentenceIndex = 0;
        progressFill.style.width = '0%';
        currentTimeSpan.textContent = '0:00';

        // Reset LRC state when loading new audio file
        lrcData = [];
        lrcLoaded = false;
        currentLrcIndex = -1;
        lyricsVisible = false;

        // Hide text display and update toggle visibility
        document.getElementById('currentText').style.display = 'none';
        updateLyricsToggleVisibility();

        // Enable controls when metadata is loaded
        audioPlayer.addEventListener('loadedmetadata', async function onMetadataLoaded() {
          enableControls();
          updateSpeedDisplay(); // Initialize speed display

          if (!callback) {
            updateStatus('Audio file ready to play', 'stopped');
          }

          // Perform silence detection to find sentence boundaries
          await detectSilenceBoundaries(file);

          // Call callback if provided
          if (callback) {
            callback();
          }

          // Auto-play the audio once it's loaded and processed
          try {
            await audioPlayer.play();
            updateStatus('Auto-playing audio...', 'playing');
          } catch (error) {
            console.log('Auto-play prevented by browser policy:', error);
            updateStatus('Audio ready to play (click Play to start)', 'stopped');
          }

          // Remove this specific listener to prevent multiple bindings
          audioPlayer.removeEventListener('loadedmetadata', onMetadataLoaded);
        });

        // Handle loading errors
        audioPlayer.addEventListener('error', function onError() {
          updateStatus('Error loading audio file', 'stopped');
          disableControls();
          audioPlayer.removeEventListener('error', onError);
        });
      }

      // ================================
      // LRC FILE HANDLING FUNCTIONS
      // ================================

      /**
       * Loads and parses LRC subtitle file
       * @param {Event} event - File input change event
       */
      function loadLrcFile(event) {
        const file = event.target.files[0];
        if (file) {
          loadLrcFileInternal(file);
        }
      }

      /**
       * Internal function to load LRC file
       * @param {File} file - LRC file to load
       */
      function loadLrcFileInternal(file) {
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            lrcData = parseLrcContent(e.target.result);
            lrcLoaded = true;

            // Show lyrics toggle button
            updateLyricsToggleVisibility();

            // Hide lyrics by default when LRC is loaded
            lyricsVisible = false;
            document.getElementById('currentText').style.display = 'none';

            // Update toggle button state to show "Show Lyrics"
            const toggleBtn = document.getElementById('lyricsToggleBtn');
            const toggleText = document.getElementById('lyricsToggleText');
            toggleBtn.classList.remove('active');
            toggleText.textContent = 'Show Lyrics';

            // Generate sentence boundaries from LRC data
            generateSentencesFromLrc();

            // Count enhanced LRC entries (with word-level timing)
            const enhancedCount = lrcData.filter((entry) => entry.isEnhanced).length;
            const enhancedText =
              enhancedCount > 0 ? ` (${enhancedCount} with word-level timing)` : '';

            updateStatus(
              `Audio and subtitles ready! Found ${lrcData.length} subtitle lines${enhancedText}, ${sentences.length} sentence segments.`,
              'stopped'
            );

            // Update text display if audio is playing
            if (audioPlayer.currentTime > 0) {
              updateCurrentText(audioPlayer.currentTime);
            }

            // Visualize the new LRC-based segments
            visualizeSegments();
          } catch (error) {
            console.error('Error parsing LRC file:', error);
            updateStatus('Error parsing LRC file - please check format', 'stopped');
          }
        };
        reader.readAsText(file);
      }

      /**
       * Generate sentence segments from LRC data
       * This provides more accurate sentence boundaries than silence detection
       */
      function generateSentencesFromLrc() {
        if (!lrcData || lrcData.length === 0) return;

        sentences = [];
        currentSentenceIndex = 0;

        for (let i = 0; i < lrcData.length; i++) {
          const currentEntry = lrcData[i];
          const nextEntry = lrcData[i + 1];

          // Calculate end time for this sentence with overlap
          let endTime;
          if (nextEntry) {
            // Extend the current sentence to overlap with the next one by 300ms
            const overlap = 0; // 50ms overlap
            endTime = nextEntry.time + overlap;
          } else {
            // For the last entry, extend by 2.5 seconds or until audio end
            endTime = Math.min(
              currentEntry.time + 2.5,
              audioPlayer.duration || currentEntry.time + 2.5
            );
          }

          sentences.push({
            start: currentEntry.time,
            end: endTime,
            text: currentEntry.text, // Store the text for reference
          });
        }

        console.log(`Generated ${sentences.length} sentences from LRC data`);
      }

      /**
       * Parses LRC file content into structured data, supporting Enhanced LRC format
       * @param {string} content - Raw LRC file content
       * @returns {Array} Array of {time, text, words} objects
       */
      function parseLrcContent(content) {
        const lines = content.split('\n');
        const lrcEntries = [];

        lines.forEach((line) => {
          // Match LRC format: [mm:ss.xx] or [mm:ss] text
          const match = line.match(/\[(\d{2}):(\d{2})(?:\.(\d{2}))?\](.+)/);
          if (match) {
            const minutes = parseInt(match[1]);
            const seconds = parseInt(match[2]);
            const centiseconds = parseInt(match[3] || '0');
            let text = match[4].trim();

            const timeInSeconds = minutes * 60 + seconds + centiseconds / 100;

            if (text) {
              // Parse Enhanced LRC format for word-level timing
              const wordTimings = parseWordTimings(text);

              // Clean text for display (remove timing tags)
              const cleanText = text.replace(/<\d{2}:\d{2}\.\d{2}>/g, '');

              lrcEntries.push({
                time: timeInSeconds,
                text: cleanText,
                words: wordTimings, // Array of {word, startTime} objects
                isEnhanced: wordTimings.length > 0,
              });
            }
          }
        });

        // Sort by time to ensure proper order
        return lrcEntries.sort((a, b) => a.time - b.time);
      }

      /**
       * Parse word-level timings from Enhanced LRC format
       * @param {string} text - Text with embedded timing tags like <00:28.73>word<00:28.98>
       * @returns {Array} Array of {word, startTime, endTime} objects
       */
      function parseWordTimings(text) {
        const words = [];
        // Enhanced LRC pattern: <mm:ss.xx>word or word<mm:ss.xx>
        const enhancedPattern = /<(\d{2}):(\d{2})\.(\d{2})>([^<]*)/g;
        let match;
        let lastEndTime = null;

        while ((match = enhancedPattern.exec(text)) !== null) {
          const minutes = parseInt(match[1]);
          const seconds = parseInt(match[2]);
          const centiseconds = parseInt(match[3]);
          const wordText = match[4].trim();

          const startTime = minutes * 60 + seconds + centiseconds / 100;

          if (wordText) {
            // Split on spaces to handle multiple words between timing tags
            const wordParts = wordText.split(/\s+/).filter((w) => w);

            wordParts.forEach((word, index) => {
              const wordStartTime = startTime + index * 0.1; // Estimate timing for multiple words
              words.push({
                word: word,
                startTime: wordStartTime,
                endTime: null, // Will be set when we know the next word's start time
              });
            });
          }
        }

        // Set end times based on next word's start time
        for (let i = 0; i < words.length - 1; i++) {
          words[i].endTime = words[i + 1].startTime;
        }

        // Set end time for last word (estimate 0.5 seconds)
        if (words.length > 0) {
          words[words.length - 1].endTime = words[words.length - 1].startTime + 0.5;
        }

        return words;
      }

      /**
       * Updates the current text display based on audio time with word-level highlighting
       * @param {number} currentTime - Current audio playback time
       */
      function updateCurrentText(currentTime) {
        if (!lrcLoaded || lrcData.length === 0) {
          return;
        }

        let activeIndex = -1;

        // Find the current subtitle line
        for (let i = 0; i < lrcData.length; i++) {
          if (currentTime >= lrcData[i].time) {
            activeIndex = i;
          } else {
            break;
          }
        }

        const textContent = document.getElementById('textContent');

        if (activeIndex !== -1) {
          const currentEntry = lrcData[activeIndex];

          // Check if this is a new line or if we need to update word highlighting
          if (activeIndex !== currentLrcIndex || currentEntry.isEnhanced) {
            currentLrcIndex = activeIndex;

            if (
              currentEntry.isEnhanced &&
              currentEntry.words &&
              currentEntry.words.length > 0
            ) {
              // Enhanced LRC with word-level timing
              displayEnhancedText(currentEntry, currentTime);
            } else {
              // Standard LRC
              textContent.innerHTML = escapeHtml(currentEntry.text);
              textContent.className = 'text-content highlighted';

              // Remove highlight after animation for standard LRC
              setTimeout(() => {
                textContent.className = 'text-content';
              }, 300);
            }
          } else if (currentEntry.isEnhanced && currentEntry.words) {
            // Update word highlighting for already displayed enhanced text
            displayEnhancedText(currentEntry, currentTime);
          }
        } else if (activeIndex === -1) {
          textContent.innerHTML = 'Waiting for subtitles...';
          textContent.className = 'text-content';
        }
      }

      /**
       * Display Enhanced LRC text with word-level highlighting
       * @param {Object} entry - LRC entry with word timings
       * @param {number} currentTime - Current playback time
       */
      function displayEnhancedText(entry, currentTime) {
        const textContent = document.getElementById('textContent');
        let html = '';

        entry.words.forEach((wordObj, index) => {
          const isCurrentWord =
            currentTime >= wordObj.startTime &&
            (wordObj.endTime ? currentTime < wordObj.endTime : true);

          const wordClass = isCurrentWord ? 'word-highlight' : 'word-normal';
          html += `<span class="${wordClass}">${escapeHtml(wordObj.word)}</span>`;

          // Add space between words (except for last word)
          if (index < entry.words.length - 1) {
            html += ' ';
          }
        });

        textContent.innerHTML = html;
        textContent.className = 'text-content enhanced-lrc';
      }

      /**
       * Escape HTML characters to prevent XSS
       * @param {string} text - Text to escape
       * @returns {string} Escaped text
       */
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      function enableControls() {
        const buttons = document.querySelectorAll(
          'button:not([onclick*="openBothFiles"]):not([onclick*="openLrcFile"])'
        );
        buttons.forEach((btn) => (btn.disabled = false));
      }

      function disableControls() {
        const buttons = document.querySelectorAll(
          'button:not([onclick*="openBothFiles"]):not([onclick*="openLrcFile"])'
        );
        buttons.forEach((btn) => (btn.disabled = true));
      }

      function onPlay() {
        isPlaying = true;
        updateStatus('Playing', 'playing');
        updatePlayPauseButton();
        // Reset auto-stop flag when playback resumes
        hasAutoStoppedForCurrentSentence = false;
      }

      function onPause() {
        isPlaying = false;
        // Clear sentence timer when paused
        if (sentenceEndTimer) {
          clearTimeout(sentenceEndTimer);
          sentenceEndTimer = null;
        }
        updateStatus('Paused', 'paused');
        updatePlayPauseButton();
      }

      function togglePlayPause() {
        if (audioPlayer && audioPlayer.src) {
          if (audioPlayer.paused) {
            if (sentenceBysentenceMode) {
              playSingleSentence();
            } else {
              audioPlayer.play().catch((error) => {
                console.error('Error playing audio:', error);
              });
            }
          } else {
            // Clear sentence timer when pausing manually
            if (sentenceEndTimer) {
              clearTimeout(sentenceEndTimer);
              sentenceEndTimer = null;
            }
            audioPlayer.pause();
          }
        }
      }

      function updatePlayPauseButton() {
        const playPauseBtn = document.getElementById('playPauseBtn');
        if (playPauseBtn) {
          if (audioPlayer && !audioPlayer.paused && !audioPlayer.ended) {
            playPauseBtn.textContent = 'Pause';
          } else {
            playPauseBtn.textContent = 'Play';
          }
        }
      }

      // ================================
      // PLAYBACK SPEED CONTROL FUNCTIONS
      // ================================

      function decreaseSpeed() {
        if (audioPlayer && audioPlayer.src) {
          const newSpeed = Math.max(0.1, audioPlayer.playbackRate - 0.1);
          audioPlayer.playbackRate = newSpeed;
          updateSpeedDisplay();
          updateStatus(
            `Speed: ${newSpeed.toFixed(1)}x`,
            isPlaying ? 'playing' : 'paused'
          );
        }
      }

      function increaseSpeed() {
        if (audioPlayer && audioPlayer.src) {
          const newSpeed = Math.min(3.0, audioPlayer.playbackRate + 0.1);
          audioPlayer.playbackRate = newSpeed;
          updateSpeedDisplay();
          updateStatus(
            `Speed: ${newSpeed.toFixed(1)}x`,
            isPlaying ? 'playing' : 'paused'
          );
        }
      }

      function resetSpeed() {
        if (audioPlayer && audioPlayer.src) {
          audioPlayer.playbackRate = 1.0;
          updateSpeedDisplay();
          updateStatus('Speed reset to 1.0x', isPlaying ? 'playing' : 'paused');
        }
      }

      function updateSpeedDisplay() {
        const speedDisplay = document.getElementById('speedDisplay');
        if (speedDisplay && audioPlayer) {
          speedDisplay.textContent = `${audioPlayer.playbackRate.toFixed(1)}x`;
        }
      }

      function onAudioEnded() {
        isPlaying = false;
        updateStatus('Finished', 'stopped');
        progressFill.style.width = '100%';
        updatePlayPauseButton();
      }

      function onAudioLoaded() {
        durationSpan.textContent = formatTime(audioPlayer.duration);
      }

      // ================================
      // LYRICS TOGGLE FUNCTIONALITY
      // ================================

      function toggleLyrics() {
        const currentText = document.getElementById('currentText');
        const toggleBtn = document.getElementById('lyricsToggleBtn');
        const toggleText = document.getElementById('lyricsToggleText');

        lyricsVisible = !lyricsVisible;

        if (lyricsVisible && lrcLoaded) {
          // Show lyrics
          currentText.style.display = 'flex';
          toggleBtn.classList.add('active');
          toggleText.textContent = 'Hide Lyrics';
        } else {
          // Hide lyrics
          currentText.style.display = 'none';
          toggleBtn.classList.remove('active');
          toggleText.textContent = 'Show Lyrics';
          lyricsVisible = false; // Ensure it's false if no LRC loaded
        }
      }

      function toggleAutoStop() {
        sentenceBysentenceMode = !sentenceBysentenceMode;

        const toggleBtn = document.getElementById('autoStopToggleBtn');
        const toggleText = document.getElementById('autoStopToggleText');

        // Clear any existing timer
        if (sentenceEndTimer) {
          clearTimeout(sentenceEndTimer);
          sentenceEndTimer = null;
        }

        if (sentenceBysentenceMode) {
          // Enable sentence-by-sentence mode
          toggleBtn.classList.add('active');
          toggleText.textContent = 'Sentence On';

          // If audio is currently playing, transition to sentence-by-sentence playback
          const wasPlaying = !audioPlayer.paused;
          if (wasPlaying) {
            // First update the current sentence index based on current playback time
            updateCurrentSentenceIndex();

            // Pause the audio
            audioPlayer.pause();

            // Small delay to ensure pause is processed, then start sentence playback
            setTimeout(() => {
              playSingleSentence();
            }, 50);
          }

          updateStatus(
            `Sentence-by-sentence mode enabled (${sentences.length} sentences)`,
            wasPlaying ? 'playing' : 'paused'
          );
        } else {
          // Disable sentence-by-sentence mode
          toggleBtn.classList.remove('active');
          toggleText.textContent = 'Sentence Off';
          updateStatus(
            'Sentence-by-sentence mode disabled',
            isPlaying ? 'playing' : 'paused'
          );
        }
      }

      function updateCurrentSentenceIndex() {
        if (sentences.length > 0) {
          for (let i = 0; i < sentences.length; i++) {
            if (
              audioPlayer.currentTime >= sentences[i].start &&
              audioPlayer.currentTime <= sentences[i].end
            ) {
              currentSentenceIndex = i;
              updateCurrentSegmentMarker();
              return;
            }
          }
        }
      }

      function playSingleSentence() {
        if (!sentenceBysentenceMode || sentences.length === 0) {
          // If not in sentence mode, play normally
          audioPlayer.play().catch((error) => {
            console.error('Error playing audio:', error);
          });
          return;
        }

        // Clear any existing timer
        if (sentenceEndTimer) {
          clearTimeout(sentenceEndTimer);
          sentenceEndTimer = null;
        }

        // Get current sentence
        const currentSentence = sentences[currentSentenceIndex];
        if (!currentSentence) {
          updateStatus('No sentence selected', 'stopped');
          return;
        }

        // Set playback to start of current sentence
        audioPlayer.currentTime = currentSentence.start;

        // Calculate duration until end of sentence
        const sentenceDuration = (currentSentence.end - currentSentence.start) * 1000; // Convert to milliseconds

        // Start playing
        audioPlayer.play().catch((error) => {
          console.error('Error playing audio:', error);
        });

        // Set timer to stop at end of sentence
        sentenceEndTimer = setTimeout(() => {
          audioPlayer.pause();
          updateStatus(
            `Completed sentence ${currentSentenceIndex + 1}/${sentences.length}`,
            'paused'
          );
          updateCurrentSegmentMarker();
        }, sentenceDuration);

        updateStatus(
          `Playing sentence ${currentSentenceIndex + 1}/${sentences.length}`,
          'playing'
        );
      }

      function updateLyricsToggleVisibility() {
        const toggleContainer = document.getElementById('lyricsToggleContainer');

        if (lrcLoaded) {
          // Show the toggle button when LRC is available
          toggleContainer.classList.add('visible');
        } else {
          // Hide the toggle button when no LRC
          toggleContainer.classList.remove('visible');
          // Also hide lyrics and reset toggle state
          const currentText = document.getElementById('currentText');
          const toggleBtn = document.getElementById('lyricsToggleBtn');
          const toggleText = document.getElementById('lyricsToggleText');

          currentText.style.display = 'none';
          toggleBtn.classList.remove('active');
          toggleText.textContent = 'Show Lyrics';
          lyricsVisible = false;
        }
      }

      function updateProgress() {
        if (audioPlayer.duration && !isNaN(audioPlayer.duration)) {
          const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
          progressFill.style.width = Math.min(100, Math.max(0, progress)) + '%';
          currentTimeSpan.textContent = formatTime(audioPlayer.currentTime);

          // Update duration if it wasn't set properly before
          if (durationSpan.textContent === '0:00') {
            durationSpan.textContent = formatTime(audioPlayer.duration);
          }

          // Update LRC text display
          updateCurrentText(audioPlayer.currentTime);
        }
      }

      function seekAudio(event) {
        if (audioPlayer.duration) {
          const progressBar = event.currentTarget;
          const rect = progressBar.getBoundingClientRect();
          const clickX = event.clientX - rect.left;
          const progressBarWidth = rect.width;
          const seekTime = (clickX / progressBarWidth) * audioPlayer.duration;
          audioPlayer.currentTime = seekTime;
        }
      }

      function formatTime(seconds) {
        if (isNaN(seconds)) return '0:00';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      function updateStatus(message, type) {
        if (statusDiv) {
          statusDiv.textContent = message;
          statusDiv.className = 'status ' + type;
        }
      }

      async function detectSilenceBoundaries(file) {
        // Only process if LRC data is available
        if (lrcLoaded && lrcData.length > 0) {
          updateStatus('Using LRC-based sentence boundaries...', 'stopped');
          generateSentencesFromLrc();
          updateStatus(
            `Using ${sentences.length} LRC-based sentence segments`,
            'stopped'
          );

          // Visualize segments on progress bar
          setTimeout(() => visualizeSegments(), 100);
          return sentences;
        } else {
          // If no LRC, just initialize empty sentences array
          sentences = [];
          currentSentenceIndex = 0;
          updateStatus('No LRC file loaded. Using simple 5-second navigation.', 'stopped');
          return sentences;
        }

        return segments;
      }

      function visualizeSegments() {
        const progressBar = document.querySelector('.progress-bar');

        // Remove existing markers
        const existingMarkers = progressBar.querySelectorAll('.segment-marker');
        existingMarkers.forEach((marker) => marker.remove());

        if (sentences.length > 0 && audioPlayer.duration) {
          sentences.forEach((segment, index) => {
            const marker = document.createElement('div');
            marker.className = 'segment-marker';
            if (index === currentSentenceIndex) {
              marker.className += ' current-segment-marker';
            }

            const position = (segment.start / audioPlayer.duration) * 100;
            marker.style.left = position + '%';

            // Add tooltip with segment info
            marker.title = `Segment ${index + 1}: ${formatTime(
              segment.start
            )} - ${formatTime(segment.end)}`;

            progressBar.appendChild(marker);
          });
        }
      }

      function updateCurrentSegmentMarker() {
        const markers = document.querySelectorAll('.segment-marker');

        markers.forEach((marker, index) => {
          if (index === currentSentenceIndex) {
            marker.className = 'segment-marker current-segment-marker';
          } else {
            marker.className = 'segment-marker';
          }
        });
      }

      // ================================
      // SENTENCE PLAYBACK FUNCTIONS
      // ================================

      function playPreviousSentence() {
        if (!lrcLoaded) {
          // No LRC - just move 3 seconds back
          const newTime = Math.max(0, audioPlayer.currentTime - 3);
          audioPlayer.currentTime = newTime;
          updateStatus('Moved back 3 seconds', isPlaying ? 'playing' : 'paused');
          // Resume playback if it was playing
          if (!audioPlayer.paused) {
            audioPlayer.play().catch((error) => {
              console.error('Error playing audio:', error);
            });
          }
        } else {
          previousSentence();
          // Auto-play the selected sentence
          if (audioPlayer.src && sentences.length > 0) {
            if (sentenceBysentenceMode) {
              playSingleSentence();
            } else {
              audioPlayer.play().catch((error) => {
                console.error('Error playing audio:', error);
              });
            }
          }
        }
      }

      function playNextSentence() {
        if (!lrcLoaded) {
          // No LRC - just move 3 seconds forward
          const newTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + 3);
          audioPlayer.currentTime = newTime;
          updateStatus('Moved forward 3 seconds', isPlaying ? 'playing' : 'paused');
          // Resume playback if it was playing
          if (!audioPlayer.paused) {
            audioPlayer.play().catch((error) => {
              console.error('Error playing audio:', error);
            });
          }
        } else {
          nextSentence();
          // Auto-play the selected sentence
          if (audioPlayer.src && sentences.length > 0) {
            if (sentenceBysentenceMode) {
              playSingleSentence();
            } else {
              audioPlayer.play().catch((error) => {
                console.error('Error playing audio:', error);
              });
            }
          }
        }
      }

      function repeatCurrentSentence() {
        // Clear any existing timer
        if (sentenceEndTimer) {
          clearTimeout(sentenceEndTimer);
          sentenceEndTimer = null;
        }

        if (sentences.length === 0) {
          // If no sentences defined, restart from current position
          if (audioPlayer.src) {
            audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 3);
            audioPlayer.play().catch((error) => {
              console.error('Error playing audio:', error);
            });
            updateStatus('Repeating current section', 'playing');
          }
          return;
        }

        // Go to the start of current sentence
        if (currentSentenceIndex >= 0 && currentSentenceIndex < sentences.length) {
          audioPlayer.currentTime = sentences[currentSentenceIndex].start;
          updateCurrentSegmentMarker();
          const duration =
            sentences[currentSentenceIndex].end - sentences[currentSentenceIndex].start;
          updateStatus(
            `Repeating sentence ${currentSentenceIndex + 1}/${
              sentences.length
            } (${formatTime(duration)})`,
            'playing'
          );

          // Use sentence-by-sentence playback if enabled, otherwise normal play
          if (sentenceBysentenceMode) {
            playSingleSentence();
          } else {
            audioPlayer.play().catch((error) => {
              console.error('Error playing audio:', error);
            });
          }
        }
      }

      function previousSentence() {
        // Clear any existing timer
        if (sentenceEndTimer) {
          clearTimeout(sentenceEndTimer);
          sentenceEndTimer = null;
        }

        if (lrcLoaded && sentences.length > 0) {
          // If we have LRC data, use sentence navigation
          currentSentenceIndex = Math.max(0, currentSentenceIndex - 1);
          if (audioPlayer.src) {
            audioPlayer.currentTime = sentences[currentSentenceIndex].start;
            updateCurrentSegmentMarker();
          }
        } else {
          // No LRC - just move 5 seconds back
          const newTime = Math.max(0, audioPlayer.currentTime - 5);
          audioPlayer.currentTime = newTime;
          updateStatus('Moved back 5 seconds', isPlaying ? 'playing' : 'paused');
        }

        // If in sentence-by-sentence mode and audio was playing, play the new sentence
        if (sentenceBysentenceMode && !audioPlayer.paused) {
          playSingleSentence();
        }
      }

      function nextSentence() {
        // Clear any existing timer
        if (sentenceEndTimer) {
          clearTimeout(sentenceEndTimer);
          sentenceEndTimer = null;
        }

        if (lrcLoaded && sentences.length > 0) {
          // If we have LRC data, use sentence navigation
          currentSentenceIndex = Math.min(sentences.length - 1, currentSentenceIndex + 1);
          if (audioPlayer.src) {
            audioPlayer.currentTime = sentences[currentSentenceIndex].start;
            updateCurrentSegmentMarker();
          }
        } else {
          // No LRC - just move 5 seconds forward
          const newTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + 5);
          audioPlayer.currentTime = newTime;
          updateStatus('Moved forward 5 seconds', isPlaying ? 'playing' : 'paused');
        }

        // If in sentence-by-sentence mode and audio was playing, play the new sentence
        if (sentenceBysentenceMode && !audioPlayer.paused) {
          playSingleSentence();
        }
      }

      // Update current sentence index based on current time
      audioPlayer.addEventListener('timeupdate', () => {
        if (sentences.length > 0) {
          for (let i = 0; i < sentences.length; i++) {
            if (
              audioPlayer.currentTime >= sentences[i].start &&
              audioPlayer.currentTime <= sentences[i].end
            ) {
              if (currentSentenceIndex !== i) {
                currentSentenceIndex = i;
                updateCurrentSegmentMarker();
                lastSentenceIndex = i;
              }
              break;
            }
          }
        }
      });

      // ================================
      // KEYBOARD SHORTCUTS & HELP
      // ================================

      /**
       * Enhanced keyboard shortcuts for better usability
       */
      document.addEventListener('keydown', (e) => {
        // Don't handle shortcuts if an input is focused
        if (isInputFocused()) {
          return;
        }

        // Handle shortcuts that work without audio loaded
        switch (e.code) {
          case 'KeyH':
          case 'F1':
            e.preventDefault();
            toggleHelp();
            return;
          case 'Escape':
            e.preventDefault();
            hideHelp();
            return;
          case 'KeyO':
            e.preventDefault();
            openBothFiles();
            return;
        }

        // Handle shortcuts that require audio to be loaded
        if (audioPlayer.src) {
          switch (e.code) {
            case 'KeyJ':
              e.preventDefault();
              playPreviousSentence();
              break;
            case 'KeyL':
              e.preventDefault();
              playNextSentence();
              break;
            case 'KeyK':
              e.preventDefault();
              togglePlayPause();
              break;
            case 'KeyU':
              e.preventDefault();
              decreaseSpeed();
              break;
            case 'KeyN':
              e.preventDefault();
              increaseSpeed();
              break;
            case 'KeyM':
              e.preventDefault();
              resetSpeed();
              break;
            case 'KeyS':
              e.preventDefault();
              if (e.ctrlKey || e.metaKey) {
                return; // Allow browser save
              }
              openLrcFile();
              break;
            case 'KeyT':
              e.preventDefault();
              if (lrcLoaded) {
                toggleLyrics();
              }
              break;
            case 'KeyA':
              e.preventDefault();
              toggleAutoStop();
              break;
          }
        }
      });

      /**
       * Check if any input element is currently focused
       */
      function isInputFocused() {
        const activeElement = document.activeElement;
        return (
          activeElement &&
          (activeElement.tagName === 'INPUT' ||
            activeElement.tagName === 'TEXTAREA' ||
            activeElement.contentEditable === 'true')
        );
      }

      /**
       * Toggle keyboard shortcuts help overlay
       */
      function toggleHelp() {
        const helpOverlay = document.getElementById('helpOverlay');

        if (helpOverlay && helpOverlay.style.display === 'flex') {
          // Help is currently visible, so hide it
          hideHelp();
        } else {
          // Help is hidden or doesn't exist, so show it
          showHelp();
        }
      }

      /**
       * Show keyboard shortcuts help overlay
       */
      function showHelp() {
        let helpOverlay = document.getElementById('helpOverlay');

        if (!helpOverlay) {
          helpOverlay = document.createElement('div');
          helpOverlay.id = 'helpOverlay';
          helpOverlay.innerHTML = `
            <div class="help-content">
              <h3>âŒ¨ï¸ Keyboard Shortcuts</h3>
              <div class="shortcut-list">
                <div><kbd>J</kbd> Play Previous</div>
                <div><kbd>L</kbd> Play Next</div>
                <div><kbd>K</kbd> Play/Pause</div>
                <div><kbd>U</kbd> Speed Down</div>
                <div><kbd>N</kbd> Speed Up</div>
                <div><kbd>M</kbd> Reset Speed</div>
                <div><kbd>A</kbd> Toggle Auto-Stop</div>
                <div><kbd>O</kbd> Load Files</div>
                <div><kbd>T</kbd> Toggle Lyrics</div>
                <div><kbd>H</kbd> Toggle Help</div>
                <div><kbd>Esc</kbd> Close Help</div>
              </div>
              <p class="help-note">ðŸ’¡ Click anywhere or press Esc to close</p>
            </div>
          `;

          helpOverlay.onclick = hideHelp;
          document.body.appendChild(helpOverlay);
        }

        helpOverlay.style.display = 'flex';
        setTimeout(() => helpOverlay.classList.add('show'), 10);
      }

      /**
       * Hide keyboard shortcuts help overlay
       */
      function hideHelp() {
        const helpOverlay = document.getElementById('helpOverlay');
        if (helpOverlay) {
          helpOverlay.classList.remove('show');
          setTimeout(() => (helpOverlay.style.display = 'none'), 300);
        }
      }

      // Initial status
      updateStatus('Select an audio file to begin', 'stopped');

      // Register Service Worker for PWA functionality
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          // Create a simple service worker inline
          const swCode = `
            const CACHE_NAME = 'audio-player-v1';
            const urlsToCache = [
              './',
              './index.html'
            ];

            self.addEventListener('install', event => {
              event.waitUntil(
                caches.open(CACHE_NAME)
                  .then(cache => cache.addAll(urlsToCache))
              );
            });

            self.addEventListener('fetch', event => {
              event.respondWith(
                caches.match(event.request)
                  .then(response => {
                    if (response) {
                      return response;
                    }
                    return fetch(event.request);
                  })
              );
            });
          `;

          const blob = new Blob([swCode], { type: 'application/javascript' });
          const swUrl = URL.createObjectURL(blob);

          navigator.serviceWorker
            .register(swUrl)
            .then((registration) => {
              console.log('Service Worker registered:', registration);
            })
            .catch((error) => {
              console.log('Service Worker registration failed:', error);
            });
        });
      }

      // Cleanup blob URLs when page unloads to prevent memory leaks
      window.addEventListener('beforeunload', () => {
        if (audioPlayer.src && audioPlayer.src.startsWith('blob:')) {
          URL.revokeObjectURL(audioPlayer.src);
        }
      });
    </script>
  </body>
</html>
